## Зміст
- [Інтерфейси та інші типи](#Інтерфейси-та-інші-типи)
  - [Інтерфейси](#Інтерфейси)
  - [Перетворення](#Перетворення)
  - [Конвертація інтерфейсів та твердження типів](#Конвертація-інтерфейсів-та-твердження-типів)
  - [Узагальнені типи](#Узагальнені-типи)
  - [Інтерфейси й методи](#Інтерфейси-й-методи)

## Інтерфейси та інші типи

### Інтерфейси
Інтерфейси у Go надають можливість визначити поведінку об'єкта: якщо _щось_ може робити _це_, то _його_ можна використовувати _тут_. Ми вже бачили кілька простих прикладів: користувацькі принтери можна реалізувати за допомогою методу `String`, а `Fprintf` може генерувати вивід на будь-що за допомогою методу `Write`. Інтерфейси з одним або двома методами є поширеним явищем у коді Go, і їм зазвичай дають назву, похідну від методу, наприклад, `io.Writer` для того, що реалізує метод `Write`.

Тип може реалізовувати декілька інтерфейсів. Наприклад, колекція може бути відсортована процедурами у пакеті `sort`, якщо він реалізує `sort.Interface`, який містить `Len()`, `Less(i, j int) bool` і `Swap(i, j int)`, а також може мати власний форматер. У цьому надуманому прикладі `Sequence` задовольняє обом вимогам.
```go
type Sequence []int

// Методи, необхідні для інтерфейсу sort.Interface.
func (s Sequence) Len() int {
    return len(s)
}
func (s Sequence) Less(i, j int) bool {
    return s[i] < s[j]
}
func (s Sequence) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

// Copy повертає копію Sequence.
func (s Sequence) Copy() Sequence {
    copy := make(Sequence, 0, len(s))
    return append(copy, s...)
}

// Метод для друку - сортує елементи перед друком.
func (s Sequence) String() string {
    s = s.Copy() // Робимо копію; не перезаписуємо аргумент.
    sort.Sort(s)
    str := "["
    for i, elem := range s { // Цикл має складність O(N²); вирішимо це у наступному прикладі.
        if i > 0 {
            str += " "
        }
        str += fmt.Sprint(elem)
    }
    return str + "]"
}
```

### Перетворення
Метод `String` у `Sequence` відтворює роботу, яку `Sprint` вже виконує для зрізів. (Він також має складність O(N²), що є поганим показником). Ми можемо розділити зусилля (а також пришвидшити роботу), якщо перетворимо `Sequence` у звичайний `[]int` перед викликом `Sprint`.
```go
func (s Sequence) String() string {
    s = s.Copy()
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
```

Цей метод є ще одним прикладом техніки перетворення для безпечного виклику `Sprintf` з методу `String`. Оскільки ці два типи (`Sequence` та `[]int`) є однаковими, якщо ігнорувати назву, перетворення між ними не є забороненим. Перетворення не створює нового значення, воно лише тимчасово діє так, ніби значення, що вже існує, має новий тип. (Існують інші легальні перетворення, наприклад, з цілого у число з рухомою комою, які створюють нове значення).

У програмах на Go існує ідіома перетворення типу виразу для доступу до іншого набору методів. Як приклад, ми можемо використати наявний тип `sort.IntSlice`, щоб звести весь приклад до цього:
```go
type Sequence []int

// Метод для друку - сортує елементи перед друком.
func (s Sequence) String() string {
    s = s.Copy()
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
```

Тепер, замість того, щоб використовувати `Sequence` для реалізації декількох інтерфейсів (сортування та друку), ми використовуємо можливість перетворення елемента даних у декілька типів (`Sequence`, `sort.IntSlice` та `[]int`), кожен з яких виконує певну частину роботи. Це більш незвично на практиці, але може бути ефективно.

### Конвертація інтерфейсів та твердження типів
[Типізований switch](https://github.com/vladyslavpavlenko/effective-go-ua/blob/main/05.%20Керуючі%20структури.md#Типізований-switch) є формою перетворення: він бере інтерфейс і для кожного випадку у `switch`, в певному сенсі, перетворює його на тип цього випадку. Ось спрощена версія того, як код у `fmt.Printf` перетворює значення у рядок за допомогою `типізованого switch`. Якщо значення вже є рядком, ми хочемо отримати власне значення рядка, яке зберігається в інтерфейсі, а якщо він має метод `String`, ми хочемо отримати результат виклику цього методу.
```go
type Stringer interface {
    String() string
}

var value interface{} // Значення, надане викликачем.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
```
У першому випадку знаходиться конкретне значення, у другому — інтерфейс перетворюється на інший інтерфейс. Змішувати типи таким чином цілком нормально.

Але що, якщо нас цікавить лише один тип? Якщо ми знаємо, що значення містить рядок, і ми просто хочемо його витягти? Для цього підійде _одноваріантний_ типізований `switch`, але також підійде і _твердження типу_. Твердження типу приймає значення інтерфейсу і витягує з нього значення вказаного явного типу. Синтаксис запозичено з умови, що відкриває типізований `switch`, але з явним типом, а не з ключовим словом `type`:
```go
value.(typeName)
```
і результатом буде нове значення зі статичним типом `typeName`. Цей тип має бути або конкретним типом, що зберігається в інтерфейсі, або другим типом інтерфейсу, до якого можна перетворити значення. Щоб витягти рядок, який, як ми знаємо, міститься у значенні, можна написати
```go
str := value.(string)
```
Але якщо виявиться, що значення не містить рядка, програма завершиться з помилкою під час виконання. Щоб уникнути цього, використовуйте ідіому «кома ok» для безпечної перевірки того, чи є значення рядком:
```go
str, ok := value.(string)
if ok {
	fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
```
Якщо перевірка типу завершиться невдачею, `str` все одно існуватиме і матиме тип `string`, але матиме нульове значення, тобто буде порожнім рядком.

Для ілюстрації цієї можливості наведено інструкцію `if`-`else`, яка еквівалентна типізованому `switch`, що відкриває цей розділ.
```go
if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
```

### Узагальнені типи
Якщо тип існує лише для реалізації інтерфейсу і ніколи не матиме експортованих методів за межами цього інтерфейсу, нема потреби експортувати сам тип. Експорт тільки інтерфейсу дає зрозуміти, що значення не має ніякої цікавої поведінки за межами того, що описано в інтерфейсі. Це також дозволяє уникнути необхідності повторювати документацію для кожного екземпляру спільного методу.

У таких випадках конструктор повинен повертати значення інтерфейсу, а не тип, що його реалізує. Наприклад, у бібліотеках хешування і `crc32.NewIEEE`, і `adler32.New` повертають інтерфейсний тип `hash.Hash32`. Заміна алгоритму `CRC-32` на `Adler-32` у програмі на Go вимагає лише зміни виклику конструктора; решта коду не зазнає впливу від зміни алгоритму.

Подібний підхід дозволяє відокремити алгоритми потокового шифрування в різних криптопакетах від блокових шифрів, які вони об'єднують. Інтерфейс `Block` у пакеті `crypto/cipher` визначає поведінку блокового шифру, який забезпечує шифрування одного блоку даних. Тоді, за аналогією з пакетом `bufio`, пакети шифрів, що реалізують цей інтерфейс, можна використовувати для побудови потокових шифрів, представлених інтерфейсом `Stream`, не знаючи деталей блокового шифрування.

Інтерфейси `crypto/cypher` виглядають наступним чином:
```go
type Block interface {
    BlockSize() int
    Encrypt(dst, src []byte)
    Decrypt(dst, src []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
```

Ось визначення потоку в режимі лічильника (CTR), який перетворює блоковий шифр на потоковий; зверніть увагу, що деталі блокового шифру абстраговані:
```go
// NewCTR повертає Stream, який шифрує/дешифрує за допомогою заданого Block у
// режимі лічильника. Довжина iv має бути такою ж, як розмір блоку Block.
func NewCTR(block Block, iv []byte) Stream
```

`NewCTR` застосовується не лише до одного конкретного алгоритму шифрування і джерела даних, але й до будь-якої реалізації інтерфейсу `Block` і будь-якого потоку. Оскільки вони повертають інтерфейсні значення, заміна шифрування CTR на інші режими шифрування є локальною зміною. Виклики конструктора необхідно відредагувати, але оскільки навколишній код повинен розглядати результат лише як потік, він не помітить різниці.

### Інтерфейси й методи
Оскільки майже будь-що може мати методи, майже будь-що може відповідати інтерфейсу. Один з ілюстративних прикладів знаходиться у пакеті `http`, який визначає інтерфейс `Handler`. Будь-який об'єкт, що реалізує `Handler`, може обслуговувати HTTP-запити.
```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```
`ResponseWriter` сам по собі є інтерфейсом, який надає доступ до методів, необхідних для повернення відповіді клієнту. Ці методи включають стандартний метод `Write`, тому `http.ResponseWriter` можна використовувати всюди, де можна використовувати `io.Writer`. `Request` — це структура, що містить синтаксично розібране представлення запиту від клієнта.

Для стислості ігноруватимемо POST і вважатимемо, що HTTP-запити завжди є GET-запитами; це спрощення не впливає на те, як налаштовані обробники. Ось тривіальна реалізація обробника для підрахунку кількості відвідувань сторінки.
```go
// Простий сервер підрахунку.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
```

(Продовжуючи нашу тему, зверніть увагу на те, як `Fprintf` може друкувати в `http.ResponseWriter`). На реальному сервері доступ до `ctr.n` потребуватиме захисту від одночасного доступу. Поради щодо цього див. у документації до пакетів `sync` і `atomic`.

Для довідки, ось як приєднати такий сервер до вузла у дереві URL-адрес.
```go
import "net/http"
// ...
ctr := new(Counter)
http.Handle("/counter", ctr)
```

Але навіщо робити `Counter` структурою? Ціле число — це все, що потрібно. (Одержувач повинен бути вказівником, щоб приріст був видимим для того, хто викликає).
```go
// Ще простіший сервер підрахунку.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
```

Що робити, якщо у вашій програмі є внутрішній стан, який має бути сповіщений про те, що сторінку було відвідано? Прив'яжіть канал до вебсторінки.
```go
// Канал, який надсилає сповіщення при кожному відвідуванні.
// (Ймовірно, канал має бути буферизованим).
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch <- req
    fmt.Fprint(w, "notification sent")
}
```

Нарешті, припустимо, що ми хочемо вивести в `/args` аргументи, які використовуються для запуску бінарного файлу сервера. Написати функцію для виведення аргументів дуже просто.
```go
func ArgServer() {
    fmt.Println(os.Args)
}
```

Як нам перетворити це на HTTP-сервер? Ми можемо зробити `ArgServer` методом якогось типу, значення якого ми ігноруємо, але є чистіший спосіб. Оскільки ми можемо визначити метод для будь-якого типу, окрім вказівників та інтерфейсів, ми можемо написати метод для функції. Пакет `http` містить такий код:
```go
// Тип HandlerFunc є адаптером, що дозволяє використовувати
// звичайні функції як обробники HTTP-запитів. Якщо f — це функція
// з відповідним підписом, HandlerFunc(f) є об'єктом Handler, 
// який викликає f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP викликає f(w, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
```

`HandlerFunc` — це тип з методом `ServeHTTP`, тому значення цього типу можуть обслуговувати HTTP-запити. Подивіться на реалізацію методу: приймачем є функція `f`, а метод викликає `f`. Це може здатися дивним, але це не набагато відрізняється від того, якби приймачем був канал, а метод — надсилав по каналу.

Щоб перетворити `ArgServer` на HTTP-сервер, ми спочатку модифікуємо його так, щоб він мав правильну сигнатуру.
```go
// Сервер аргументів.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
```

`ArgServer` тепер має ту саму сигнатуру, що й `HandlerFunc`, тому його можна перетворити в цей тип, щоб отримати доступ до його методів, так само як ми перетворили `Sequence` на `IntSlice`, щоб отримати доступ до `IntSlice.Sort`. Код для його налаштування лаконічний:
```go
http.Handle("/args", http.HandlerFunc(ArgServer))
```

Коли хтось відвідує сторінку `/args`, обробник, встановлений на цій сторінці, має значення `ArgServer` і тип `HandlerFunc`. HTTP-сервер викличе метод `ServeHTTP` цього типу, з `ArgServer` як отримувачем, який своєю чергою викличе `ArgServer` (через виклик `f(w, req)` всередині `HandlerFunc.ServeHTTP`). Після цього будуть відображені аргументи.

У цьому розділі ми створили HTTP-сервер зі структури, цілого числа, каналу та функції, а все тому, що інтерфейси — це просто набір методів, які можна визначити для (майже) будь-якого типу.
