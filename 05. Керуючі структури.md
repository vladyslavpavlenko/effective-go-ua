## Зміст
- [Керуючі структури](#Керуючі-структури)
  - [If](#If)
  - [Перевизначення й перепризначення](#Перевизначення-й-перепризначення)
  - [For](#For)
  - [Switch](#Switch)
  - [Типізований switch](#Типізований-switch)

## Керуючі структури
Керуючі структури у Go подібні до таких у C, але відрізняються важливими особливостями. У Go немає циклу `do` або `while`, є лише дещо узагальнений `for`; `switch` є більш гнучким; `if` і `switch` приймають необов'язковий оператор ініціалізації, як і `for`; оператори `break` і `continue` приймають необов'язкову мітку для визначення того, що потрібно перервати або продовжити; і є нові керуючі структури, включаючи типізований `switch` і багатоканальний мультиплексор комунікацій, `select`. Синтаксис також дещо відрізняється: немає круглих дужок, а тіло завжди повинно бути розділене фігурними дужками.

### If
У Go простий if-вираз виглядає так:
```go
if x > 0 {
    return y
}
```
Обов'язкові дужки спрощують написання простих інструкцій `if` у декількох рядках. Так чи інакше, це гарний стиль, особливо коли тіло містить оператор керування, такий як `return` або `break`.

Оскільки `if` і `switch` допускають оператор ініціалізації, їх часто використовують для встановлення локальної змінної.
```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```
У бібліотеках Go ви побачите, що коли інструкція `if` не переходить у наступну інструкцію, тобто тіло закінчується `break`, `continue`, `goto` або `return`, непотрібна умова `else` опускається.
```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```
Нижче наведено приклад поширеної ситуації, коли код є захищеним від послідовності помилок. Код читається добре, якщо виконується без помилок, оминаючи випадки їх виникнення. Оскільки обробки помилок, як правило, закінчуються операторами `return`, то код не потребує використання операторів `else`.
```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

### Перевизначення й перепризначення
**Зауваження:** Останній приклад у попередньому розділі демонструє, як працює форма короткого оголошення `:=`. Оголошення, яке викликає `os.Open`, виглядає так,
```go
f, err := os.Open(name)
```
у цьому виразі оголошуються дві змінні, `f` та `err`. Кількома рядками пізніше йде виклик `f.Stat`,
```go
d, err := f.Stat()
```
який виглядає так, ніби він оголошує `d` та `err`. Зверніть увагу, що `err` з'являється в обох операторах. Це дублювання є законним: `err` оголошується в першому виразі, але лише _перепризначається_ в другому. Це означає, що виклик `f.Stat` використовує змінну `err`, що вже існує, оголошену вище, і просто присвоює їй нове значення.

В оголошенні `:=` змінна `v` може бути присутньою, навіть якщо вона вже була оголошена, за наступних умов:
- оголошення відбувається в тій же самій області видимості, що й наявна змінна `v` (якщо `v` уже оголошено за межами видимості, то оголошення створить нову змінну<sup>§</sup>)
- відповідне значення, під час ініціалізації, може бути присвоєно `v`
- існує хоча б одна нова змінна в оголошенні, яка буде створена заново

Ця незвичайна властивість — чиста практичність, яка слугує для використання однієї змінної `err`, наприклад, у довгому ланцюжку `if-else`. Ви побачите, що вона часто використовується.

<sup>§</sup>Варто зазначити, що у Go область видимості параметрів функції та значень, що повертаються, збігається з областю видимості тіла функції, хоча лексично вони знаходяться за межами фігурних дужок, що охоплюють тіло функції.

### For
Цикл `for` у Go схожий на відповідний цикл C, але він не є таким самим. Цей уніфікує `for` і `while`, але не містить `do-while`. Існує три форми, лише одна з яких має крапку з комою.
```go
// C-подібний for
for init; condition; post { }

// С-подібний while
for condition { }

// C-подібний for(;;)
for { }
```
Короткі оголошення дозволяють легко оголосити початкові умови прямо в циклі.
```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```
Якщо ви виконуєте цикл над масивом, зрізом, рядком або мапою, або читаєте з каналу, то для керування циклом можна використати оператор `range`.
```go
for key, value := range oldMap {
    newMap[key] = value
}
```
Якщо вам потрібен лише перший елемент у _діапазоні_ (ключ або індекс), відкиньте другий:
```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```
Якщо вам потрібен лише другий елемент у _діапазоні_ (значення), використовуйте _порожній ідентифікатор_ (_), щоб відкинути перший:
```go
sum := 0
for _, value := range array {
    sum += value
}
```
Порожній ідентифікатор має багато сценаріїв використання та буде описаний у [подальшому розділі](#Порожній-ідентифікатор).

Для рядків `range` робить більше роботи за вас, зокрема виділяє окремі символи Unicode, виконуючи парсинг UTF-8. Помилкові кодування займають один байт і створюють руну (rune) заміни U+FFFD. (Назва (з відповідним вбудованим типом) руни є термінологією Go для одного символу Unicode. Детальніше дивіться у [специфікації мови](https://go.dev/ref/spec#Rune_literals) (англ.)). Цикл
```go
for pos, char := range "日本\x80語" { // \x80 не є коректним кодуванням UTF-8
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```
виводить
```
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
```

Наостанок, Go не має оператора `кома`, а `++` і `--` є інструкціями, а не виразами. Таким чином, якщо ви хочете використати декілька змінних в операторі `for`, вам слід скористатися паралельним присвоюванням (це виключає можливість використання `++` і `--`).
```go
// Обертання масиву a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### Switch
У мові Go `switch` є більш узагальненим, ніж у C. Вирази не обов'язково мають бути константами або навіть цілими числами, умови перевіряються зверху-вниз до знаходження відповідності, і якщо `switch` не має виразів, то переходить у `true`. Отже, ідіоматично можливо записувати `if-else-if-else` ланцюжок як `switch`.
```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

Автоматичний пропуск умов відсутній, але, при цьому, вони можуть бути записані через кому:
```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

Попри те, що вони не настільки поширені в Go, як у деяких інших C-подібних мовах, `break` може бути використаний для дострокового переривання `switch`. Хоча іноді треба перервати зовнішній (стосовно `switch`) цикл, а не сам `switch`, і в Go цього можна досягти шляхом додавання мітки перед циклом, і переходом до цієї мітки в разі виклику `break`. У наступному прикладі представлені обидва випадки:
```go
Loop:
    for n := 0; n < len(src); n += size {
        switch {
        case src[n] < sizeOne:
            if validateOnly {
                break
            }
            size = 1
            update(src[n])

        case src[n] < sizeTwo:
            if n+1 >= len(src) {
                err = errShortInput
                break Loop
            }
            if validateOnly {
                break
            }
            size = 2
            update(src[n] + src[n+1]<<shift)
        }
    }
```

Звичайно, інструкція `continue` також допускає використання міток, але це стосується лише циклів.

На завершення цього розділу наведемо процедуру порівняння фрагментів байтів, яка використовує два оператори `switch`:
```go
// Compare повертає ціле число, яке є результатом порівняння двох
// масивів байтів, лексикографічно.
// Результат буде 0, якщо a == b, -1, якщо a < b, і +1, якщо a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```

### Типізований switch
Оператор `switch` також можна використовувати для визначення динамічного типу інтерфейсних змінних. Таким чином, типізований `switch` використовує синтаксис перевірки типу з ключовим словом `type` у дужках. Якщо `switch` оголошує змінну у виразі, змінна матиме відповідний тип у кожному його пункті. Також ідіоматично повторно використовувати імена змінних у таких випадках, фактично оголошуючи нову змінну з тим самим іменем, але з іншим типом у кожному випадку.
```go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T виводить тип змінної t
case bool:
    fmt.Printf("boolean %t\n", t)             // t має тип bool
case int:
    fmt.Printf("integer %d\n", t)             // t має тип int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t має тип *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t має тип *int
}
```