## Зміст
- [Дані](#Дані)
  - [Створення за допомогою new](#Створення-за-допомогою-new)
  - [Конструктори та складені літерали](#Конструктори-та-складені-літерали)
  - [Створення за допомогою make](#Створення-за-допомогою-make)
  - [Масиви](#Масиви)
  - [Зрізи](#Зрізи)
  - [Двовимірні зрізи](#Двовимірні-зрізи)
  - [Мапи](#Мапи)
  - [Друк](#Друк)
  - [Приєднання](#Приєднання)

## Дані
### Створення за допомогою new
У Go є два примітиви виділення, вбудовані функції `new` і `make`. Вони роблять різні речі і застосовуються до різних типів, що може заплутати, але правила їх використання досить прості. Спочатку поговоримо про `new`. Це вбудована функція, яка виділяє пам'ять, але на відміну від своїх тезок у деяких інших мовах вона _не ініціалізує_ пам'ять, а лише _обнуляє_ її. Тобто `new(T)` виділяє обнулену пам'ять для нового елемента типу `T` і повертає його адресу — значення типу `*T`. У термінології Go, вона повертає вказівник на щойно виділене нульове значення типу `T`.

Оскільки пам'ять, яку повертає `new`, обнуляється, при проєктуванні структур даних корисно передбачити, що нульове значення кожного типу можна використовувати без додаткової ініціалізації. Це означає, що користувач структури даних може створити її за допомогою `new` і одразу приступити до роботи. Наприклад, у документації до `bytes.Buffer` зазначено, що «нульове значення для Buffer — це порожній буфер, готовий до використання». Аналогічно, `sync.Mutex` не має явного конструктора або методу `Init`. Натомість, нульове значення для `sync.Mutex` визначається як розблокований м'ютекс.

Властивість «нульове-значення-є-корисним» працює транзитивно. Розглянемо таке оголошення типу.
```go
type SyncedBuffer struct {
    lock   sync.Mutex
    buffer bytes.Buffer
}
```
Значення типу `SyncedBuffer` також готові до використання одразу після виділення або просто оголошення. У наступному фрагменті і `p`, і `v` будуть коректно працювати без додаткових змін.
```go
p := new(SyncedBuffer) // тип *SyncedBuffer
var v SyncedBuffer     // тип SyncedBuffer
```

### Конструктори та складені літерали
Іноді нульового значення недостатньо і потрібен ініціалізуючий конструктор, як у прикладі з пакету `os`, наведеному нижче.
```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```
Існує багато шаблонів. Ми можемо спростити його за допомогою використання _складеного літерала_, тобто виразу, який створює новий екземпляр щоразу, коли він обчислюється.
```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```
Зверніть увагу, що, на відміну від мови C, повертати адресу локальної змінної цілком нормально; адреса, пов'язана зі змінною, зберігається після повернення функції. Насправді, отримання адреси складеного літерала виділяє новий екземпляр кожного разу, коли він обчислюється, тому ми можемо об'єднати ці два останні рядки.
```go
return &File{fd, name, nil, 0}
```
Поля складеного літерала розташовані у певному порядку і всі з них повинні бути присутніми. Однак, якщо позначити елементи явно як пари `поле: значення`, ініціалізатори можуть з'являтися у довільному порядку, а відсутні поля будуть проініціалізовані як відповідні нульові значення. Таким чином, можна сказати
```go
    return &File{fd: fd, name: name}
```
У граничному випадку, якщо складений літерал взагалі не містить полів, він створює нульове значення для типу. Таким чином, вирази `new(File)` і `&File{}` еквівалентні.

Складені літерали також можна створювати для масивів, зрізів і мап, при цьому мітками полів можуть бути індекси або ключі мап відповідно. У цих прикладах ініціалізації працюють незалежно від значень `Enone`, `Eio` та `Einval`, якщо вони є різними.
```go
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
```

### Створення за допомогою make
Повернемося до виділення пам'яті. Вбудована функція `make(T, args)` має інше призначення, відмінне від `new(T)`. Вона створює лише зрізи, мапи та канали і повертає _ініціалізоване_ (не обнулене) значення типу `T` (а не `*T`). Причиною такої відмінності є те, що ці три типи представляють собою посилання на структури даних, які необхідно ініціалізувати перед використанням. Наприклад, зріз — це дескриптор з трьох елементів, що містить вказівник на дані (всередині масиву), довжину та ємність, і поки ці елементи не ініціалізовано, зріз має _нульове_ (nil) значення. Для зрізів, мап і каналів `make` ініціалізує внутрішню структуру даних і готує значення до використання. Наприклад,
```go
make([]int, 10, 100)
```
виділяє пам'ять для масиву розміром 100 значень типу `int`, а потім створює структуру зрізу довжиною 10 і ємністю 100 з посиланням, яке вказує лише на перші 10 елементів масиву. (При створенні зрізу ємність можна не вказувати; див. [розділ про зрізи](#Зрізи) для отримання додаткової інформації). На противагу цьому, `new([]int)` повертає вказівник на щойно виділену, обнулену структуру зрізу, тобто вказівник на `nil` значення зрізу.

Подальші приклади ілюструють різницю між `new` та `make`:
```go
var p *[]int = new([]int)       // виділяє структуру зрізу; *p == nil; рідко коли корисно
var v  []int = make([]int, 100) // тепер зріз v відсилає до нового масиву зі 100 цілих чисел

// Зайве ускладнення:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Ідіоматично:
v := make([]int, 100)
```

Пам'ятайте, що `make` застосовується лише до мап, зрізів та каналів і не повертає вказівник. Щоб отримати явний вказівник, виділіть його за допомогою `new` або візьміть адресу змінної явно.

### Масиви
Масиви корисні, коли точно відома необхідна кількість необхідної пам'яті, щоб не робити зайвих перестворень, але насамперед вони є складовою частиною для зрізів, які буде описано в [наступному розділі](#Зрізи).

Існують суттєві відмінності між тим, як працюють масиви у Go та C. У Go,
- Масиви — це значення. Присвоєння одного масиву іншому копіює всі елементи.
- Зокрема, якщо ви передаєте масив у функцію, вона отримає копію масиву, а не вказівник на нього.
- Розмір масиву є частиною його типу. Типи `[10]int` та `[20]int` є різними.

Властивість `value` може бути корисною, але також і дорогою; якщо ви хочете C-подібну поведінку та ефективність, можете передати вказівник на масив.
```go
func Sum(a *[3]float64) (sum float64) {
for _, v := range *a {
sum += v
}
return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Зверніть увагу на явний оператор адресації
```
Але такий стиль не є ідіоматичним для Go. Натомість, використовуйте зрізи замість масивів.

### Зрізи
Зрізи обгортають масиви, надаючи більш загальний, потужний і зручний інтерфейс для послідовностей даних та керування ними. За винятком елементів з явною розмірністю, таких як матриці перетворень, більшість програм для роботи з масивами у Go використовують зрізи, а не з прості масиви.

Зрізи містять посилання на базовий масив, і якщо ви призначаєте один з них іншому, обидва посилаються на той самий масив. Якщо функція отримує аргумент зрізу, зміни, які вона вносить до елементів зрізу, будуть видимими для користувача, аналогічно до передачі вказівника на базовий масив. Таким чином, функція `Read` може приймати аргумент зрізу, а не вказівник і лічильник; довжина в межах зрізу встановлює верхню межу кількості даних, які можна прочитати. Ось сигнатура методу `Read` типу `File` у пакеті `os`:
```go
func (f *File) Read(buf []byte) (n int, err error)
```
Метод повертає кількість прочитаних байт і значення помилки, якщо вона виникла. Щоб прочитати перші 32 байти більшого буфера `buf`, розріжте буфер.
```go
n, err := f.Read(buf[0:32])
```
Таке розбиття на фрагменти є поширеним і ефективним. Насправді, якщо залишити ефективність осторонь, наступний фрагмент також прочитає перші 32 байти буфера.
```go
 var n int
    var err error
    for i := 0; i < 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Прочитає один байт.
        n += nbytes
        if nbytes == 0 || e != nil {
            err = e
            break
        }
    }
```
Довжину зрізу можна змінювати доти, доки він не виходить за межі базового масиву; просто призначте його зрізу самого себе. Максимальну довжину, яку може мати зріз, можна дізнатися скориставшись вбудованою функцією `cap`. Ось функція для додавання даних до зрізу. Якщо дані перевищують ємність, зріз перерозподіляється. Отриманий фрагмент повертається. Функція використовує той факт, що `len` і `cap` можна застосувати до `nil` зрізу, отримавши 0.
```go
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // реалокація
        // Виділяємо подвійну кількість потрібного, для майбутнього зростання.
        newSlice := make([]byte, (l+len(data))*2)
        // Функція copy є попередньо оголошеною і працює для будь-якого типу зрізу.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    copy(slice[l:], data)
    return slice
}
```
Після цього ми повинні повернути зріз, тому що, хоча `Append` може змінювати елементи зрізу, сам зріз (структура даних часу виконання, що містить вказівник, довжину та ємність) передається _за значенням_.

Ідея додавання до зрізу є настільки корисною, що її реалізовано у вбудованій функції `append`. Однак, щоб зрозуміти принцип роботи цієї функції, нам потрібно трохи більше інформації, тому ми повернемося до неї пізніше.

### Двовимірні зрізи
Масиви та зрізи в Go є одновимірними. Щоб створити еквівалент двовимірного масиву або зрізу, необхідно визначити масив з масивів або зріз зі зрізів, як показано нижче:
```go
type Transform [3][3]float64 // Масив розміру 3x3, по суті — масив масивів.
type LinesOfText [][]byte    // Зріз зрізу байтів.
```
Оскільки зрізи мають змінну довжину, можна зробити так, щоб кожен внутрішній зріз мав різну довжину. Це може бути поширеною ситуацією, як у нашому прикладі `LinesOfText`: кожен рядок має незалежну довжину.
```go
text := LinesOfText{
    []byte("Ви знаєте, як липа шелестить..."),
    []byte("у місячні весняні ночі?"),
    []byte("А солов'ї!..."),
}
```
Іноді необхідно виділити 2D-зріз — ситуація, яка може виникнути, наприклад, при обробці ліній розгортки пікселів. Існує два способи зробити це. Перший — виділити кожен зріз незалежно; другий — виділити єдиний масив і вказати на нього окремі зрізи. Який з них використовувати, залежить від вашої програми. Якщо зрізи можуть збільшуватися або зменшуватися, їх слід виділяти незалежно, щоб уникнути перезапису наступного рядка; якщо ні, то може бути ефективніше побудувати об'єкт за допомогою одного виділення. Для довідки, ось ескізи двох методів. Спершу, по одному рядку за раз:
```go
// Виділити зріз верхнього рівня.
picture := make([][]uint8, YSize) // Один рядок на кожну одиницю y.
// Перебрати рядки, виділяючи зріз для кожного рядка.
for i := range picture {
    picture[i] = make([]uint8, XSize)
}
```
А тепер як одне виділення, розрізане на рядки:
```go
// Виділити зріз верхнього рівня, так само як раніше.
picture := make([][]uint8, YSize) // Один рядок на кожну одиницю y.
// Виділити один великий зріз для зберігання всіх пікселів.
pixels := make([]uint8, XSize*YSize) // Має тип []uint8, хоча picture має тип [][]uint8.
// Перебрати рядки, виділяючи кожний рядок із передньої частини залишку зрізу пікселів.
for i := range picture {
    picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
```

### Мапи
Мапи — це зручна і потужна вбудована структура даних, яка пов'язує значення одного типу (_ключ_) зі значеннями іншого типу (_елемент_ або _значення_). Ключ може бути будь-якого типу, для якого визначено оператор рівності, наприклад, цілі числа, числа з плаваючою комою та комплексні числа, рядки, вказівники, інтерфейси (якщо динамічний тип підтримує рівність), структури та масиви. Зрізи не можна використовувати як ключі мапи, оскільки для них не визначена рівність. Як і зрізи, мапи містять посилання на базову структуру даних. Якщо ви передаєте мапу у функцію, яка змінює її вміст, ці зміни будуть діяти лише в для того, хто її викликає.

Мапи можна створювати за допомогою звичайного синтаксису складених літералів з парами ключ-значення, розділеними двокрапкою, тому їх легко створювати під час ініціалізації.
```go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
```

Присвоєння та отримання значень мап синтаксично виглядає так само, як і для масивів та зрізів, за винятком того, що індекс не обов'язково має бути цілим числом.
```go
offset := timeZone["EST"]
```

Спроба отримати значення мапи за ключем, якого у ній немає, поверне нульове значення для типу записів мапи. Наприклад, якщо мапа містить цілі числа, пошук за неіснуючим ключем поверне 0. Множину (`set`) можна реалізувати у вигляді мапи зі значенням типу `bool`. Встановіть для елемента карти значення `true`, щоб помістити значення у множину, а потім перевірте його простим індексуванням.
```go
attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    // ...
}

if attended[person] { // буде false, якщо особа відсутня у мапі
    fmt.Println(person, "was at the meeting")
}
```

Іноді вам потрібно відрізнити відсутній запис від нульового значення. Чи є запис для `"UTC"`, чи це 0, тому що його взагалі немає у мапі? Ви можете розрізняти це за допомогою форми множинного присвоєння.
```go
var seconds int
var ok bool
seconds, ok = timeZone[tz]
```
Зі зрозумілих причин це називається ідіомою «кома ok». У цьому прикладі, якщо `tz` присутня, секунди будуть встановлені належним чином і значення `ok` буде істинним; якщо ж ні, секунди будуть встановлені на нуль і значення `ok` буде хибним. Ось функція, яка поєднує це з гарним звітом про помилки:
```go
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
```

Щоб перевірити наявність у мапі, не турбуючись про фактичне значення, ви можете використовувати порожній ідентифікатор (_) замість звичайної змінної для значення.
```go
_, present := timeZone[tz]
```

Щоб видалити запис мапи, скористайтеся вбудованою функцією `delete`, аргументами якої є мапа і ключ, який потрібно видалити. Це безпечно робити, навіть якщо ключ вже відсутній на мапі.
```go
delete(timeZone, "PDT")  // Тепер за стандартним часом
```

### Друк
Форматований друк у Go використовує стиль, подібний до сімейства `printf` у C, але багатший і загальніший. Відповідні функції знаходяться у пакеті `fmt` і мають назви з великої літери: `fmt.Printf`, `fmt.Fprintf`, `fmt.Sprintf` і так далі. Рядкові функції (`Sprintf` тощо) повертають рядок, а не заповнюють наданий буфер.

Вам не потрібно вказувати рядок форматування. Для кожної з функцій `Printf`, `Fprintf` і `Sprintf` існує інша пара функцій, наприклад `Print` і `Println`. Ці функції не приймають рядок форматування, а генерують формат за замовчуванням для кожного аргументу. Версії `Println` також вставляють пропуск між аргументами і додають новий рядок до друку, тоді як версії `Print` додають пропуски лише у тому випадку, якщо операнд з обох боків не є рядком. У цьому прикладі кожен рядок виводить однакові дані.
```go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

Функції форматованого друку `fmt.Fprint` та інші приймають як перший аргумент будь-який об'єкт, що реалізує інтерфейс `io.Writer`; змінні `os.Stdout` та `os.Stderr` є знайомими екземплярами.

Тут все починає відрізнятися від C. По-перше, числові формати, такі як `%d`, не приймають прапорів знаковості або розміру; натомість, підпрограми друку використовують тип аргументу для визначення цих властивостей.
```go
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
```
виведе
```
18446744073709551615 ffffffffffffffff; -1 -1
```

Якщо вам потрібне перетворення за замовчуванням, наприклад, десяткове для цілих чисел, ви можете скористатися загальним форматом `%v` (для «значення»); результат буде таким самим, як і за допомогою команд `Print` і `Println`. Крім того, цей формат може виводити будь-які значення, навіть масиви, зрізи, структури та мапи. Нижче наведено інструкцію друку для мапи часових поясів, визначеної у попередньому розділі.
```go
fmt.Printf("%v\n", timeZone)  // або ж просто fmt.Println(timeZone)
```
що виведе:
```
map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]
```

Для мап `Printf` і друзі сортують висновок лексикографічно за ключем.

Під час друку структури модифікований формат `%+v` анотує поля структури їхніми назвами, а для будь-якого значення альтернативний формат `%#v` друкує значення у повному синтаксисі Go.
```go
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```
Виводить:
```
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string]int{"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0}
```

Зверніть увагу на амперсанди. Цей формат рядка у лапках також доступний за допомогою `%q`, якщо його застосовано до значення типу рядок або `[]byte`. Альтернативний формат `%#q` за можливості використовує зворотні лапки. (Формат `%q` також застосовується до цілих чисел і рун, створюючи рунічну константу в одинарних лапках). Крім того, `%x` працює з рядками, масивами байт і зрізами байт так само, як і з цілими числами, створюючи довгий шістнадцятковий рядок, а з пробілом у форматі (`% x`) він ставить пробіли між байтами.

Ще одним зручним форматом є `%T`, який виводить тип значення.
```go
fmt.Printf("%T\n", timeZone)
```
Виводить:
```
map[string]int
```

Якщо ви хочете керувати форматом за замовчуванням для користувацького типу, все, що вам потрібно, це визначити метод з сигнатурою `String()` рядка для цього типу. Для нашого простого типу `T` це може виглядати так.
```go
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```
Для виведення у форматі:
```
7/-2.35/"abc\tdef"
```

(Якщо вам потрібно виводити значення типу `T`, а також вказівники на `T`, приймач для `String` має бути типу значення; у цьому прикладі використано вказівник, оскільки це ефективніше та ідіоматичніше для структурних типів. Для отримання додаткової інформації зверніться до [розділу про вказівники та приймачі значень](https://github.com/vladyslavpavlenko/effective-go-ua/blob/main/9.%20Методи.md#Методи)).

Наш метод `String` може викликати `Sprintf`, тому що процедури друку повністю реентерабельні і можуть бути обернуті таким чином. Однак у цьому підході є одна важлива деталь: не створюйте метод `String` за допомогою виклику `Sprintf` таким чином, щоб він повторювався у вашому методі `String` нескінченно. Це може статися, якщо виклик `Sprintf` спробує надрукувати приймач безпосередньо як рядок, що, у свою чергу, призведе до повторного виклику методу. Як показує цей приклад, це поширена і легка помилка.
```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Помилка: нескінченне повторення.
}
```
Це також легко виправити: перетворіть аргумент до базового рядкового типу, який не має методу.
```go
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // ОК: зверніть увагу на зведення типу.
}
```

У [розділі про ініціалізацію](https://github.com/vladyslavpavlenko/effective-go-ua/blob/main/8.%20Ініціалізація.md#Ініціалізація) ми розглянемо інший метод, який дозволяє уникнути цієї рекурсії.

Інша техніка друку полягає у передачі аргументів процедури друку безпосередньо іншій такій процедурі. Сигнатура `Printf` використовує тип `...interface{}` для останнього аргументу, щоб вказати, що після формату може з'явитися довільна кількість параметрів (довільного типу).
```go
func Printf(format string, v ...interface{}) (n int, err error) {
```

Усередині функції `Printf` `v` діє як змінна типу `[]interface{}`, але якщо її передати в іншу варіадну функцію, то вона діє як звичайний список аргументів. Ось реалізація функції `log.Println`, яку ми використовували вище. Вона передає свої аргументи безпосередньо до `fmt.Sprintln` для фактичного форматування.
```go
// Println друкує в стандартний лог у стилі fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output приймає параметри (int, string)
}
```

Ми пишемо `...` після `v` у вкладеному виклику `Sprintln`, щоб вказати компілятору розглядати `v` як список аргументів; інакше він просто передасть `v` як єдиний аргумент типу зріз.

Існує набагато більше можливостей для друку, ніж ми розглянули тут. Докладнішу інформацію наведено у документації до пакету `fmt` у розділі `godoc`.

До речі, параметр `...` може бути певного типу, наприклад, `...int` для функції `min`, яка вибирає найменше зі списку цілих чисел:
```go
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // найбільший int
    for _, i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
```

### Приєднання
Тепер у нас є відсутній шматочок, який нам був потрібен для пояснення дизайну вбудованої функції `append`. Сигнатура `append` відрізняється від нашої користувацької функції `Append` вище. Схематично це виглядає так:
```go
func append(slice []T, elements ...T) []T
```

де `T` — це місцезаповнювач для будь-якого заданого типу. Насправді ви не можете написати функцію на Go, де тип `T` визначається тим, хто її викликає. Саме тому `append` є вбудованою функцією: вона потребує підтримки компілятора.

Що робить `append`, так це додає елементи в кінець фрагмента і повертає результат. Результат потрібно повертати, тому що, як і у випадку з нашим власним `Append`, базовий масив може змінитися. Цей простий приклад
```go
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```
виводить `[1 2 3 4 5 6]`. Отже, `append` працює трохи подібно до `Printf`, збираючи довільну кількість аргументів.

Але що, якщо ми хочемо зробити те, що робить наш `Append`, і додати зріз до зрізу? Легко: використовуйте `...` у місці виклику, так само, як ми це зробили у виклику `Output` вище. Цей код створить такий самий вивід, як і наведений вище.
```go
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
```
Без цього `...`, він не скомпілюється, оскільки типи будуть неправильними; `y` не є типом `int`.